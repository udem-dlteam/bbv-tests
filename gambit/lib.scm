(define (LIBstring=? str1 str2)
  (let ((len (Sstring-length str1)))
    (and (SFX= len (Sstring-length str2))
         (let loop ((i (SFX- len 1)))
           (or (SFX< i 0)
               (and (Schar=? (Sstring-ref str1 i) (Sstring-ref str2 i))
                    (loop (SFX- i 1))))))))

(define (LIBstring<? str1 str2)
  (let loop ((i 0))
    (if (SFX< i (Sstring-length str1))
        (if (SFX< i (Sstring-length str2))
            (let ((c1 (Sstring-ref str1 i))
                  (c2 (Sstring-ref str2 i)))
              (and (Schar<? c1 c2)
                   (loop (SFX+ i 1))))
            #f)
        (SFX< i (Sstring-length str2)))))

(define (LIBstring-ci=? str1 str2)
  (let ((len (Sstring-length str1)))
    (and (SFX= len (Sstring-length str2))
         (let loop ((i (SFX- len 1)))
           (or (SFX< i 0)
               (and (Schar=? (Schar-downcase (Sstring-ref str1 i))
                             (Schar-downcase (Sstring-ref str2 i)))
                    (loop (SFX- i 1))))))))

(define (LIBequal? x y)
  (cond ((eq? x y)
         #t)
        ((pair? x)
         (and (pair? y)
	      (LIBequal? (Scar x) (Scar y))
	      (LIBequal? (Scdr x) (Scdr y))))
        ((pair? y)
         #f)
        ((FLONUM? x)
         (and (FLONUM? y) (SFL= x y)))
        ((FLONUM? y)
         #f)
        ((vector? x)
         (and (vector? y)
              (let ((len (vector-length x)))
	        (and (SFX= len (vector-length y))
	             (let loop ((i (SFX- len 1)))
	               (or (SFX< i 0)
		           (and (LIBequal? (Svector-ref x i) (Svector-ref y i))
		                (loop (SFX- i 1)))))))))
        ((string? x)
         (and (string? y)
              (Sstring=? x y)))
        ((or (null? x) (eq? x #f) (eq? x #t) (char? x) (symbol? x)
             (null? y) (eq? y #f) (eq? y #t) (char? y) (symbol? y))
         #f)
        (else
         (equal? x y)))) ;; call the builtin equal? as a fallback

(define (LIBlist->vector elem-list)

  (define (concat elem-list i)
    (if (pair? elem-list)
        (let ((x (Scar elem-list)))
          (let ((result (concat (Scdr elem-list) (SFX+ i 1))))
            (Svector-set! result i x)
            result))
        (Smake-vector1 i)))

  (concat elem-list 0))

(define (LIBlist->string char-list)

  (define (concat char-list i)
    (if (pair? char-list)
        (let ((x (Scar char-list)))
          (let ((result (concat (Scdr char-list) (SFX+ i 1))))
            (Sstring-set! result i x)
            result))
        (Smake-string1 i)))

  (concat char-list 0))

(define (LIBstring->list str)
  (let loop ((i (SFX- (Sstring-length str) 1)) (result '()))
    (if (SFX>= i 0)
        (loop (SFX- i 1) (cons (Sstring-ref str i) result))
        result)))

(define (LIBstring-concatenate string-and-char-list)

  (define (concat string-and-char-list i)
    (if (pair? string-and-char-list)
        (let ((x (Scar string-and-char-list)))
          (if (char? x)
              (let ((result (concat (Scdr string-and-char-list) (SFX+ i 1))))
                (Sstring-set! result i x)
                result)
              (let* ((n (Sstring-length x))
                     (result (concat (Scdr string-and-char-list) (SFX+ i n))))
                (let loop ((j (SFX- (Sstring-length x) 1)))
                  (if (SFX>= j 0)
                      (begin
                        (Sstring-set! result (SFX+ i j) (Sstring-ref x j))
                        (loop (SFX- j 1)))
                      result)))))
        (Smake-string1 i)))

  (concat string-and-char-list 0))

(define (LIBstring-append . strings)
  (LIBstring-concatenate strings))

(define (LIBconcatenate list-of-lists)

  (define (concat first rest)
    (if (pair? rest)
        (Sappend first (concat (Scar rest) (Scdr rest)))
        first))

  (if (pair? list-of-lists)
      (concat (Scar list-of-lists) (Scdr list-of-lists))
      '()))
